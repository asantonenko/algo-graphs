# algo-graphs
Алгоритми на графах


Нахождение кратчайших путей от заданной вершины до всех остальных вершин алгоритмом Дейкстры
http://e-maxx.ru/algo/dijkstra

Алгоритм Дейкстры
https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%94%D0%B5%D0%B9%D0%BA%D1%81%D1%82%D1%80%D1%8B

Алгоритм Дейкстры и его реализация средствами STL
https://www.e-olymp.com/uk/blogs/posts/21

Реализация алгоритма Дейкстры для решение задачи "Кратчайший путь" в ООП стиле на языке C++

Опишем вначале вспомагательные структуры.

Для начала опишем структуру, описывающую ребро графа. 
![2020-11-06_114736.png](https://static.e-olymp.com/content/99/999753d5406bc6ca0f054fc8e28decd52648bb71.png)

Для каждого ребра храним куда оно идет и его длину. Логичный вопрос - почему не храним откуда оно выходит? Дело в том, что граф будет храниться списками смежностями, и  i-тый список смежности соответствует ребрам, исходящим из i-той вершины. Реализовано два конструктора и метод read (в данной реализации не понадобился).

Далее структура для приоритетной очереди - содержит номер вершины и длину пути до неё:
![2020-11-06_115338.png](https://static.e-olymp.com/content/4e/4e89ab1837c7af9d9517119a7ed5f2c48f518c03.png)

Для этой структуры мы определили оператор сравнения < - элемент меньше, следовательно его приоритет в очереди меньше, если расстояние до него больше.

Класс graph содержит следующие поля:
![2020-11-06_115559.png](https://static.e-olymp.com/content/73/732d32d6925b500cb3eae2e0e493bddde5266caa.png)

В конструкторе графа создаем граф с указанным количеством вершин и без ребер (пустой граф).
![2020-11-06_115932.png](https://static.e-olymp.com/content/7d/7d5887b3c8642cbf15657c9a8d0036cd404df272.png)

Методы добавления ребер, вершин и подсчета количества вершин:
![2020-11-12_092847.png](https://static.e-olymp.com/content/43/4346ad20d8281fda8cffb51c181d7623dcb387aa.png)

Инициализация алгоритма Дейкстры, включает создание и инициализацию массивов dist и parent:
![2020-11-12_111435.png](https://static.e-olymp.com/content/3f/3f9f506f0082f69416f3c66f454104356de73935.png)

Основная часть алгоритма (расчет расстояний dist и родительских вершин parent):
![2020-11-12_111724.png](https://static.e-olymp.com/content/2b/2ba3f57753ecc97b568ddf604427d6e3954a9185.png)

В конце в поле класса start запоминаем, какая вершина была стартовой,
после этого будут разблокированы следующие методы, которые возвращают 
информацию о кратчайшем расстоянии и пути:
![2020-11-12_112032.png](https://static.e-olymp.com/content/1c/1c3f05ecc013d507fe9514d5101c92d046066687.png)

Методы определения достижимости вершины из начальной и возврата найденного расстояния, сами методы ничего не считают, вызываются только после работы метода dijkstra.
![2020-11-12_112238.png](https://static.e-olymp.com/content/7b/7b2a3222a809fa25d9371d43bc4bcb45e82b476b.png)

Метод нахождения кратчайшего пути от start до finish (использует информацию, полученную методом dijkstra):
![2020-11-12_112732.png](https://static.e-olymp.com/content/b1/b17342b1b302c1ad8c4db3479b9738d4619ca4c6.png)


## Решение на C#

Для начала заменим, что в C# до .NET 6 нет встроенной приоритетной очереди, поэтому пришлось её взять отсюда: https://gist.github.com/paralleltree/31045ab26f69b956052c

Выглядит она примерно так (начало класса):

![Screenshot 2022-10-19 142452.png](https://static.eolymp.com/content/5c/5ca764f6c8c585325077798cf8d823a63251493a.png)

(конец класса)

![Screenshot 2022-10-19 142715.png](https://static.eolymp.com/content/45/45251f23a29e72eb31f60319288b934fc9178941.png)

Для добавление в приоритетную очередь используется метод public void Enqueue(T x), а для извлечения самого приоритетного элемента - метод public T Dequeue(). По умолчанию, для данной реализации, самый приоритетный - это самый маленький в порядке, который задаётся реализацией интерфейса IComparable<T> в классе T. Заметим, что я сделал ровно одно изменение в коде приоритетной очереди - потребовал реализации интерфейса IComparable<T>, а не IComparable, как в оригинале - обратите внимание на заголовок универсального (generic) класса PriorityQueue:

    class PriorityQueue<T> where T : IComparable<T>

Далее объявим вспомогательные типы - класс, реализующий ребро графа(Edge):

![Screenshot 2022-10-19 142957.png](https://static.eolymp.com/content/26/262771a510ab66d7b32b93a764a88a2cb4ed2677.png)

и вершину графа (Vertex) - вместе с расстоянием до неё.

![Screenshot 2022-10-19 143023.png](https://static.eolymp.com/content/3f/3f8ce26e828f3c08f3784e53af95abd588f04483.png)

Приведем теперь собственно класс граф (Graph)

![Screenshot 2022-10-19 143251.png](https://static.eolymp.com/content/a3/a3a862c4d5b6c5a6a6351117fe9665e4d3d446c2.png)

и метод Дейкстры, вычисляющий по графу Graph g и номеру начальной вершины int start
массивы расстояний out int[] distance и предков вершин out int[] parent. Для начала укажем заголовок функции и инициализацию переменных:

![Screenshot 2022-10-19 143337.png](https://static.eolymp.com/content/42/4276276fa60d62d23c29ed8fd4e76c5db3774d3d.png)

Создаём приоритетную очередь и кладём в неё начальную вершину

![Screenshot 2022-10-19 143408.png](https://static.eolymp.com/content/9c/9c35bfdd78757249effbf01023a46bf7b82bf4ca.png)

Основная часть алгоритма (цикл пока в приоритетной очереди еще есть вершины - расчет расстояний distance и родительских вершин parent):

![Screenshot 2022-10-19 143445.png](https://static.eolymp.com/content/e3/e353f3f6284bc8ebaa5212378c7a00be34136bdd.png)

В Main считываем граф с консоли

![Screenshot 2022-10-19 144249.png](https://static.eolymp.com/content/6e/6eb7bafb235e06155c0b5389629951037f63efeb.png)

затем запускаем метод Dijkstra

![Screenshot 2022-10-19 144249.png](https://static.eolymp.com/content/6e/6eb7bafb235e06155c0b5389629951037f63efeb.png)

если до финишной вершины f не дошли печатаем -1

![Screenshot 2022-10-19 144515.png](https://static.eolymp.com/content/13/136fab3f8a96339c3fd19d8cc4da36f128a27c50.png)

иначе печатаем длину пути и восстанавливаем весь путь, начиная с финишной вершины f до стартовой s, пользуясь массивом parent

![Screenshot 2022-10-19 144651.png](https://static.eolymp.com/content/ce/ce656607c25f94bdb61daa9d4bde1688f824d060.png)
