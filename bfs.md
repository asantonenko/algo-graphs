Рассмотрим основные моменты решения Найкоротший шлях (https://www.eolymp.com/uk/problems/4853)

Для начала введем количество вершин, ном ера начальной и конечной вершины, а также матрицу смежности графа:
![2020-10-22_111855.png](https://static.e-olymp.com/content/38/389ba39dc2d0334bc014da5d02a7f38037fd3504.png)

Отмечу основные моменты - номера вершин удобно уменьшить на единицу, т.к. нумерация индексов в массивах идет с нуля (в исходной задаче нумерация вершин с единицы), я объявил матрицу n на n с элементами типа bool, но написать просто cin >> adj_matr[i][j]; нельзя, поэтому приходится использовать промежуточную целую переменную tmp для ввода.

Объявим и инициализируем необходимые переменные для обхода:

![2020-10-22_112334.png](https://static.e-olymp.com/content/da/da92d238cc5aa77feb0e81099f10c600ff2c6037.png)

Нам нужен массив расстояний dist (целые числа, по умолчанию INT_MAX - которое обозначает расстояние, равное бесконечности - для непосещенных вершин). В данной задаче не нужен массив предков вершин parent, но я его написал для полноты картины (-1 обозначает, что нет предка - для стартовой и непосещенных вершин).

Ну и необходима очередь с номерами вершин для обхода в ширину. Для начала в очередь помещаем стартовую вершину, расстояние до нее равно 0.

Основной код обхода - это цикл, пока очередь непуста:

![2020-10-22_113136.png](https://static.e-olymp.com/content/4e/4ef9007725ebdcda8be8de79475941c20d9b8fff.png)

Берем первый элемент из очереди (при помощи методов front - взять первый и pop - удалить первый) и помещаем в current - номер текущей вершины.
Эту вершины можно было бы в этом месте покрасить в черный цвет, но нам это не нужно, мы вообще явно цвет не храним, но, посещена ли вершина, можно узнать по значению дистанции до нее (dist[next] != INT_MAX - и обозначает, что вершина next еще не посещена - т.е. расстояние до нее бесконечное).

Далее пробегаем все вершины, куда можно попасть из вершины current. Т.к. граф задан матрицей, приходится пробегать по строке данной матрицы и проверять, что в матрице стоит 1. Если бы граф был бы задан списками смежности, мы бы просто перебрали бы элементы списка смежности вершины current - для примеров см. описание поиска в глубину. Кроме того, мы идем только в непосещенные вершины next. Очевидным образом вычисляем расстояние dist[next] - на единицу больше чем dist[current], предком вершины next является вершина current.

В итоге, dist[finish] равно расстоянию до конечной вершины, если до нее можно добраться из начальной. Иначе, dist[finish] равно INT_MAX.

Также приведу код, который не нужен в данной задаче, но позволяет найти путь до вершины:

![2020-10-22_114123.png](https://static.e-olymp.com/content/38/38d026e4b4d26619e01e576b4f1ddc0a0ebd5c0c.png)

Вектор path - это искомый путь (список вершин) - получаем в обратном порядке, начиная с вершины finish, переходя к предку, пока не попадем в вершину start. Алгоритм reverse разворачивает полученный в обратном порядке путь, приводя к прямому порядку. Напомним, что при печати элементов пути el, мы прибавляем единицу, т.к. индексы в массивах хранятся, начиная с 0, а нам нужно вывести номера, начинающиеся с единицы, т.е. на единицу большие чем индексы.

Также см. https://e-maxx.ru/algo/bfs
