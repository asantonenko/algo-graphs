## Ссылки на необходимые алгоритмы

Поиск в глубину
https://e-maxx.ru/algo/dfs

Алгоритм поиска компонент связности в графе
https://e-maxx.ru/algo/connected_components

Проверка графа на ацикличность и нахождение цикла
https://e-maxx.ru/algo/finding_cycle

## Заготовки на языке С++ (фрагменты из моих решений олимпиадных задач):

Подключение заголовочных файлов и объявление переменных:

![graph_includes_variables.png](https://static.e-olymp.com/content/d2/d2bf840ddc708c685db9020619e6461ed5ca323b.png)

обратите внимание на олимпиадный стиль - использование using namespace std; и глобальных переменных - вполне адекватно и нормально в олимпиадном, но не в реальном / коммерческом программировании. 

Ввод графа с клавиатуры:

По условию задачи:

В первой строке заданы количество вершин *n* и ребер *m* в графе соответственно (1 ≤ *n* ≤ 100, 1 ≤ *m* ≤ 10000). Каждая из следующих m строк содержит по два числа *ui* и *vi* (1 ≤ *ui*, *vi* ≤ *n*); каждая такая строка означает, что в графе существует ребро между вершинами *ui* и *vi*.

![graph_read.png](https://static.e-olymp.com/content/c7/c709c1bc95ec7fe39458f6c41976c5a4e60f1ba7.png)

Так как используются глобальные переменные вместо локальных - приходится использовать метод resize вместо объявления вектора нужной размерности. *x*-- и *y*-- использованы так как нумерация в условии задачи начинается с единицы, а в C++ в массивах нумерация начинается с нуля. Единственная проблема - сложность при отладке программ - ну и не забывать при вводе уменьшать номера вершин на единицу, а при выводе обратно увеличивать на единицу.

Единственная разница кода для ориентированных графов и неориентированных, что в неориентированном графе прочитав очередное ребро *u* -> *v*, необходимо добавить также ребро *v* -> *u*, код будет следующим:

		cin >>u >>v;
		u--; v--;
		graph[u].push_back(v);
		graph[v].push_back(u);

Приведу также базовый вариант dfs из моего кода к задаче "Связность"

![base_dfs.png](https://static.e-olymp.com/content/48/4887781b29ffe8560450bb3551a4a894be2938e3.png)

Замечу, что

- в этом варианте необязательно перекрашивать вершины в черный цвет в конце, но это необходимо, например, для нахождения цикла в ориентированном графе;
- данный вариант dfs ничего не возвращает, тем не менее, часто нужен вариант dfs, что-то возвращающий. Например, для удобства определения количества компонент связности сделаем вариант данного обхода, который будет возвращать true если мы нашли и закрасили новую компоненту, и false, если мы попали в вершину, которая изначально покрашена.

![bool_dfs.png](https://static.e-olymp.com/content/ff/ffd4a773e4e7f2d8c9be233464fb1481b253cc09.png)


Заметим, что не во всех случаях граф должен быть представлен в явном виде, например в задаче "Площадь комнаты" граф представлен двумерной матрицей. 

![lab_dfs.png](https://static.e-olymp.com/content/be/be7c2c9e5a7271b81c8bd27201ecb5ab5e425077.png)

В данном случае вместо номера вершины используется пара координат ( *i*, *j*), а вместо цикла по всем вершинам инцидентным данной, используется явное перечисление всех 4-х ребер, идущих вверх, вниз, влево, вправо:

		dfs(i-1,j);dfs(i+1,j);dfs(i,j-1);dfs(i,j+1);

Только не забывайте проверять возможность выхода за пределы матрицы. Кстати, в данном *рабочем* коде это не проверяется - почему (подсказка - см. условие задачи).
